# Ответы на вопросы

## 1. В чём основные отличия сортировок пузырьком, выбором и вставками?

Сортировка пузырьком работает так: она много раз проходит по массиву и каждый раз сравнивает соседние элементы. Если они стоят неправильно, то меняет их местами. Большие элементы как будто «всплывают» вправо, поэтому она и называется пузырьковой. Этот алгоритм простой, но очень медленный на больших массивах.

Сортировка выбором работает иначе. Она ищет самый маленький элемент во всём массиве и ставит его на первое место, потом ищет следующий минимальный элемент и ставит его на второе место, и так далее. Она делает меньше обменов элементов, чем пузырьковая сортировка, но всё равно работает долго при большом количестве данных.

Сортировка вставками похожа на то, как люди сортируют карты в руках. Берётся один элемент и вставляется в нужное место среди уже отсортированных элементов. Если массив почти отсортирован, она работает быстро, но если данные случайные и большие — становится медленной.

---

## 2. Почему параллельную сортировку вставками сложно сделать с OpenMP?

Потому что сортировка вставками очень зависит от порядка действий. Каждый следующий шаг зависит от того, что произошло раньше. Если несколько потоков одновременно начнут двигать элементы, они могут мешать друг другу и портить данные. Поэтому потоки не могут спокойно работать независимо друг от друга, как в других алгоритмах. Из-за этого распараллеливание сортировки вставками получается сложным и не всегда правильным.

---

## 3. Какие директивы OpenMP были использованы?

В программе использовалась директива:

- `#pragma omp parallel for`

Она говорит компилятору разделить выполнение цикла между несколькими потоками.

Также использовались следующие директивы OpenMP:

- `#pragma omp parallel`
- `#pragma omp for`
- `#pragma omp critical`

Они необходимы для того, чтобы несколько потоков могли работать одновременно, но при этом не возникало конфликтов при доступе к общим данным.

---

## 4. Какие плюсы и минусы параллельной сортировки на CPU?

**Плюсы:**
- Увеличение скорости выполнения при работе с большими массивами данных
- Более эффективное использование вычислительных ресурсов процессора

**Минусы:**
- Накладные расходы на создание и управление потоками
- Для небольших массивов параллельная версия может работать медленнее последовательной
- Не все алгоритмы удобно и эффективно распараллеливаются

---

## 5. Как измерить производительность программы в C++?

Производительность измеряют с помощью времени выполнения. В C++ для этого удобно использовать библиотеку `chrono`. Сначала запоминается время до начала выполнения алгоритма, затем время после его завершения, и вычисляется разница между ними. Полученное значение показывает, сколько времени программа выполнялась (обычно в миллисекундах).

---

## 6. Как меняется производительность при увеличении числа потоков?

Если объём данных большой, то при увеличении количества потоков программа обычно начинает работать быстрее. Однако рост производительности не бесконечен. В определённый момент добавление новых потоков почти не даёт ускорения, так как процессор оказывается полностью загружен или потоки начинают мешать друг другу.

---

## 7. Когда параллельная сортировка может быть хуже последовательной?

Параллельная сортировка может быть менее эффективной, если размер массива небольшой. В этом случае время, затрачиваемое на создание и синхронизацию потоков, превышает время выполнения самой сортировки. Также снижение производительности возможно, если алгоритм плохо подходит для параллельной реализации или если используется слишком большое количество потоков.

