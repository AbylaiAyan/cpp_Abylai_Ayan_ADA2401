# Assignment 1 - C++ and OpenMP

## Описание проекта
В этом репозитории собраны все задания по первой лабораторной работе по C++ и OpenMP.  
Цель заданий — научиться работать с динамическими массивами, вычислять среднее значение элементов массива, искать минимальные и максимальные значения, а также использовать параллельные вычисления с OpenMP.  
Все программы написаны с учётом правильного выделения и освобождения динамической памяти.

---

## Содержание заданий

### Task 1
- Создаём динамический массив из 50 000 целых чисел.  
- Заполняем массив случайными числами от 1 до 100.  
- Вычисляем среднее значение элементов массива.  
- Программа показывает, как работать с динамической памятью через указатели.

### Task 2
- Создаём большой массив из 1 000 000 элементов.  
- Реализуем **последовательный** поиск минимального и максимального числа.  
- Считаем время выполнения алгоритма, чтобы понять, сколько занимает работа с большими данными.

### Task 3
- Используем массив из Task 2.  
- Реализуем **параллельный** поиск минимального и максимального числа с помощью OpenMP.  
- Сравниваем время работы параллельного и последовательного алгоритмов.  
- Эта задача показывает, как можно ускорять вычисления с помощью нескольких потоков.

### Task 4
- Создаём массив из 5 000 000 чисел.  
- Вычисляем среднее значение **последовательно** и **параллельно с OpenMP** используя `reduction`.  
- Сравниваем время работы обеих реализаций, чтобы увидеть, насколько параллельные вычисления могут быть эффективными на больших данных.

---

## Как запускать программы

1. Скачайте репозиторий или клонируйте его через GitHub.  
2. Откройте нужный `.cpp` файл в Visual Studio или другом компиляторе C++.  
3. Для задач с OpenMP (Task 3 и Task 4) нужно включить поддержку OpenMP:  
   - **Visual Studio:** свойства проекта → C/C++ → Language → OpenMP Support → Yes  
   - **g++:** добавьте флаг `-fopenmp` при компиляции  
4. Скомпилируйте и запустите файл. В консоли увидите результаты работы программы — минимумы, максимумы, средние значения и время выполнения.

---

## Дополнительно

- Все задачи корректно освобождают динамическую память после работы.  
- Параллельные задачи демонстрируют ускорение на больших массивах, хотя на маленьких массивах параллельная версия может быть даже чуть медленнее из-за накладных расходов на потоки.  
- Код написан простым, понятным языком, чтобы любой новичок мог понять, как работает динамическая память и OpenMP.

---

## Структура репозитория

Assignment1/
├─ source1.cpp # Среднее значение для массива 50 000

├─ source2.cpp # Последовательный поиск min/max для 1 000 000

├─ source3.cpp # Параллельный поиск min/max с OpenMP

├─ source4.cpp # Среднее значение параллельно и последовательно

└─ README.md # Описание репозитория и инструкций



## Контрольные вопросы к Assignment 1

### 1. В чём отличие динамического массива от статического массива в C++?
- Статический массив создаётся заранее и его размер нельзя менять, например `int arr[10];`.  
- Динамический массив создаём во время работы программы через `new`, его размер можно задавать во время выполнения.  

### 2. Что такое указатель и зачем он нужен?
- Указатель хранит адрес памяти, где лежит переменная или массив.  
- Когда мы создаём динамический массив, указатель нужен, чтобы обращаться к этой памяти и потом её освобождать через `delete[]`.

### 3. Почему важно освобождать память после использования массива?
- Если не освобождать память, она остаётся занятой и может вызвать ошибки или замедление программы.  
- В больших программах это особенно важно, чтобы не было утечек памяти.

### 4. В чём разница между последовательной и параллельной обработкой массива?
- Последовательно: обрабатываем элементы один за другим.  
- Параллельно: массив делим на части, и несколько потоков работают сразу, что может ускорить работу на больших данных.

### 5. Что делает `#pragma omp parallel for`?
- Эта директива говорит компилятору, что цикл должен выполняться **параллельно** разными потоками.  

### 6. Для чего нужен `reduction` в OpenMP?
- `reduction` помогает безопасно объединять результаты, которые вычисляют разные потоки.  
- Например, чтобы посчитать сумму элементов массива параллельно, чтобы итог был правильный.

### 7. Почему нельзя просто использовать обычную переменную для суммы в параллельном цикле?
- Если несколько потоков будут одновременно писать в одну переменную, результат получится неправильным.  
- `reduction` решает эту проблему, создавая локальные копии для каждого потока и потом объединяя их.

### 8. Почему параллельная версия иногда может быть медленнее последовательной?
- Если массив маленький, накладные расходы на потоки могут быть больше выигрыша.  
- Если мало ядер на компьютере.  
- Если есть блокировки или другие синхронизации в коде.  
- Если работа между потоками распределена плохо.

