# Assignment 1 - C++ and OpenMP

## Описание проекта
В этом репозитории собраны все задания по первой лабораторной работе по C++ и OpenMP.  
Цель заданий — научиться работать с динамическими массивами, вычислять среднее значение элементов массива, искать минимальные и максимальные значения, а также использовать параллельные вычисления с OpenMP.  
Все программы написаны с учётом правильного выделения и освобождения динамической памяти.

---

## Содержание заданий

### Task 1
- Создаём динамический массив из 50 000 целых чисел.  
- Заполняем массив случайными числами от 1 до 100.  
- Вычисляем среднее значение элементов массива.  
- Программа показывает, как работать с динамической памятью через указатели.

### Task 2
- Создаём большой массив из 1 000 000 элементов.  
- Реализуем **последовательный** поиск минимального и максимального числа.  
- Считаем время выполнения алгоритма, чтобы понять, сколько занимает работа с большими данными.

### Task 3
- Используем массив из Task 2.  
- Реализуем **параллельный** поиск минимального и максимального числа с помощью OpenMP.  
- Сравниваем время работы параллельного и последовательного алгоритмов.  
- Эта задача показывает, как можно ускорять вычисления с помощью нескольких потоков.

### Task 4
- Создаём массив из 5 000 000 чисел.  
- Вычисляем среднее значение **последовательно** и **параллельно с OpenMP** используя `reduction`.  
- Сравниваем время работы обеих реализаций, чтобы увидеть, насколько параллельные вычисления могут быть эффективными на больших данных.

---

## Как запускать программы

1. Скачайте репозиторий или клонируйте его через GitHub.  
2. Откройте нужный `.cpp` файл в Visual Studio или другом компиляторе C++.  
3. Для задач с OpenMP (Task 3 и Task 4) нужно включить поддержку OpenMP:  
   - **Visual Studio:** свойства проекта → C/C++ → Language → OpenMP Support → Yes  
   - **g++:** добавьте флаг `-fopenmp` при компиляции  
4. Скомпилируйте и запустите файл. В консоли увидите результаты работы программы — минимумы, максимумы, средние значения и время выполнения.

---

## Дополнительно

- Все задачи корректно освобождают динамическую память после работы.  
- Параллельные задачи демонстрируют ускорение на больших массивах, хотя на маленьких массивах параллельная версия может быть даже чуть медленнее из-за накладных расходов на потоки.  
- Код написан простым, понятным языком, чтобы любой новичок мог понять, как работает динамическая память и OpenMP.

---

## Структура репозитория

Assignment1/
├─ source1.cpp # Среднее значение для массива 50 000

├─ source2.cpp # Последовательный поиск min/max для 1 000 000

├─ source3.cpp # Параллельный поиск min/max с OpenMP

├─ source4.cpp # Среднее значение параллельно и последовательно

└─ README.md # Описание репозитория и инструкций



## Контрольные вопросы к Assignment 1
(Основы C/C++ и OpenMP)

### 1. В чём отличие динамического массива от статического массива в языке C++?
Статический массив создаётся на стеке с фиксированным размером, известным на этапе компиляции. Его размер нельзя изменить во время выполнения программы. Динамический массив создаётся в куче с помощью оператора `new`, размер которого можно задавать во время выполнения программы. Динамические массивы позволяют работать с большими объёмами данных и управлять памятью более гибко.

### 2. Что такое указатель и зачем он используется при работе с динамической памятью?
Указатель - это переменная, которая хранит адрес другой переменной или области памяти. При работе с динамическими массивами указатель необходим для доступа к памяти, выделенной в куче, и для её последующего освобождения с помощью оператора `delete[]`.

### 3. Почему важно корректно освобождать память после использования динамических массивов?
Невыполнение освобождения памяти приводит к утечкам памяти, когда выделенные блоки остаются занятыми, даже если программа их больше не использует. Это может привести к увеличению потребления ресурсов и снижению производительности программы, особенно при работе с большими массивами или длительными вычислениями.

### 4. В чём разница между последовательной и параллельной обработкой массива?
Последовательная обработка выполняет операции над элементами массива по одному в установленном порядке. Параллельная обработка делит массив на части, которые обрабатываются одновременно несколькими потоками, что позволяет ускорить вычисления на многопроцессорных системах.

### 5. Что делает директива `#pragma omp parallel for`?
Директива `#pragma omp parallel for` указывает компилятору, что следующий цикл `for` следует выполнять параллельно. Каждая итерация цикла распределяется между доступными потоками, что позволяет выполнять вычисления одновременно на нескольких ядрах.

### 6. Для чего используется механизм `reduction` в OpenMP?
Механизм `reduction` позволяет безопасно объединять результаты локальных переменных каждого потока в одну итоговую переменную. Например, при параллельном вычислении суммы элементов массива `reduction(+:sum)` гарантирует корректное суммирование результатов всех потоков.

### 7. Почему при параллельном вычислении суммы необходимо использовать `reduction`, а не обычную переменную?
Использование обычной переменной приведёт к одновременным записям нескольких потоков в один и тот же объект, что вызовет гонку данных и некорректный результат. `Reduction` создаёт локальные копии для каждого потока и объединяет их корректно, обеспечивая правильность вычислений.

### 8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?
- Малый размер массива: накладные расходы на создание и синхронизацию потоков могут превышать выигрыш от параллельной обработки.  
- Недостаточное количество ядер процессора.  
- Частое использование блокировок или критических секций, замедляющих потоки.  
- Неравномерное распределение работы между потоками, что приводит к простою некоторых потоков.


